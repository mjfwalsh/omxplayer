#pragma once

// Author: Michael Walsh (2022)

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <mutex>
#include <condition_variable>

class Mailbox {
public:
  enum Type {
    ADD_DVD_SUBS,
    REMOVE_DVD_SUBS,
    PUSH,
    SEND_INTERNAL_SUBS,
    FLUSH,
    TOGGLE_EXTERNAL_SUBS,
    SET_PAUSED,
    SET_DELAY,
    DISPLAY_TEXT,
    CLEAR_RENDERER,
    EXIT,
  };

  class Item {
    public:
    explicit Item(const enum Type &t) : type(t) {};
    virtual ~Item() {};

    enum Type type;
    Item *next = NULL;
  };
  class DVDSubs : public Item
  {
    public:
    DVDSubs(Dimension &v, float &va, int &am, uint32_t *p) :
      Item(ADD_DVD_SUBS), video(v), video_aspect(va), aspect_mode(am), palette(p) {};

    Dimension video;
    float video_aspect;
    int aspect_mode;
    uint32_t *palette;
  };
  class Push : public Item
  {
    public:
    explicit Push(Subtitle &s) : Item(PUSH), subtitle(s) {};

    Subtitle subtitle;
  };
  class SendInternalSubs : public Item
  {
    public:
    SendInternalSubs() : Item(SEND_INTERNAL_SUBS) {};

    std::vector<Subtitle> subtitles;
  };
  class ToggleExternalSubs : public Item
  {
    public:
    explicit ToggleExternalSubs(bool v) : Item(TOGGLE_EXTERNAL_SUBS), visible(v) {};

    bool visible;
  };
  class SetPaused : public Item
  {
    public:
    explicit SetPaused(bool v) : Item(SET_PAUSED), value(v) {};

    bool value;
  };
  class SetDelay : public Item
  {
    public:
    explicit SetDelay(bool v) : Item(SET_DELAY), value(v) {};

    int value;
  };
  class DisplayText : public Item
  {
    public:
    DisplayText(const char *tl, int d, bool w)
    : Item(DISPLAY_TEXT),
      text_lines(tl),
      duration(d),
      wait(w)
    {};

    std::string text_lines;
    int duration;
    bool wait;
  };

  void send(Item *elem)
  {
    std::lock_guard<std::mutex> look(messages_lock);

    if(tail == NULL) {
      head = tail = elem;
    } else {
      tail->next = elem;
      tail = elem;
    }
    messages_cond.notify_one();
  }

  Item *receive()
  {
    std::lock_guard<std::mutex> look(messages_lock);

    if(head == NULL) {
      return NULL;
    } else {
      Item *old_head = head;
      head = head->next;

      if(head == NULL)
        tail = NULL;

      return old_head;
    }
  }

  void wait(const std::chrono::milliseconds &rel_time)
  {
    std::unique_lock<std::mutex> lock(messages_lock);
    messages_cond.wait_for(lock, rel_time, [&]{return head != NULL;});
  }

  void clear()
  {
    std::lock_guard<std::mutex> look(messages_lock);

    while(head != NULL)
    {
      Item *old_head = head;
      head = head->next;
      delete old_head;
    }
    tail = NULL;
  }

private:
  Item *head = NULL;
  Item *tail = NULL;

  std::mutex messages_lock;
  std::condition_variable messages_cond;
};
