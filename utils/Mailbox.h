#pragma once

// Author: Torarin Hals Bakke (2012)

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <mutex>
#include <condition_variable>

#include "LockBlock.h"

class Mailbox {
public:
  enum Type {
    DVD_SUBS,
    PUSH,
    SEND_INTERNAL_SUBS,
    CLEAR_INTERNAL_SUBS,
    TOGGLE_EXTERNAL_SUBS,
    UNSET_TIME,
    SET_PAUSED,
    SET_DELAY,
    DISPLAY_TEXT,
    CLEAR_RENDERER,
    EXIT,
  };

  class Item {
    public:
    Item(enum Type t) : type(t), next(NULL) {};

    enum Type type;
    Item *next;
  };
  class DVDSubs : public Item
  {
    public:
    DVDSubs(Dimension v, float va, int am, uint32_t *p) :
      Item(DVD_SUBS), video(v), video_aspect(va), aspect_mode(am), palette(p) {};

    Dimension video;
    float video_aspect;
    int aspect_mode;
    uint32_t *palette;
  };
  class Push : public Item
  {
    public:
    Push(Subtitle s) : Item(PUSH), subtitle(s) {};

    Subtitle subtitle;
  };
  class SendInternalSubs : public Item
  {
    public:
    SendInternalSubs() : Item(SEND_INTERNAL_SUBS) {};

    std::vector<Subtitle> subtitles;
  };
  class ClearInternalSubs : public Item
  {
    public:
    ClearInternalSubs() : Item(CLEAR_INTERNAL_SUBS) {};
  };
  class ToggleExternalSubs : public Item
  {
    public:
    ToggleExternalSubs(bool v) : Item(TOGGLE_EXTERNAL_SUBS), visible(v) {};

    bool visible;
  };
  class UnsetTime  : public Item {
    public:
    UnsetTime() : Item(UNSET_TIME) {};
  };
  class SetPaused : public Item
  {
    public:
    SetPaused(bool v) : Item(SET_PAUSED), value(v) {};

    bool value;
  };
  class SetDelay : public Item
  {
    public:
    SetDelay(bool v) : Item(SET_DELAY), value(v) {};

    int value;
  };
  class DisplayText : public Item
  {
    public:
    DisplayText(std::string tl, int d) : Item(DISPLAY_TEXT), text_lines(tl), duration(d) {};

    std::string text_lines;
    int duration;
  };
  class ClearRenderer : public Item
  {
    public:
    ClearRenderer() : Item(CLEAR_RENDERER) {};
  };
  class Exit : public Item
  {
    public:
    Exit() : Item(EXIT) {};
  };

  void send(Item *elem) {
    LOCK_BLOCK (messages_lock) {
      if(tail == NULL) {
        head = tail = elem;
      } else {
        tail->next = elem;
        tail = elem;
      }
      messages_cond.notify_one();
    }
  }

  Item *receive() {
    LOCK_BLOCK (messages_lock) {
      if(head == NULL) {
        return NULL;
      } else {
        Item *old_head = head;
        head = head->next;

        if(head == NULL)
          tail = NULL;

        return old_head;
      }
    }
    return NULL; // this never happens
  }

  void wait(const chrono::milliseconds &rel_time)
  {
    std::unique_lock<std::mutex> lock(messages_lock);
    messages_cond.wait_for(lock, rel_time, [&]{return head != NULL;});
  }

  void clear()
  {
    LOCK_BLOCK(messages_lock)
    {
      while(head != NULL)
      {
        Item *old_head = head;
        head = head->next;
        delete old_head;
      }
      tail = NULL;
    }
  }

private:
  Item *head = NULL;
  Item *tail = NULL;

  std::mutex messages_lock;
  std::condition_variable messages_cond;
};
